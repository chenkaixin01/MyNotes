# 1 LLM-bot

## 1.1 数据采集
- 专业知识人员采集或者客户内部积累的高质量非结构化内容，可直接用于RAG chunk；也可以作为分类器过滤的冷启动数据
- 从网络或者或其他渠道爬取的数据，需要经过数据清洗后再进入RAG
- 客户内部积累的结构化内容可以直接进入问答库
## 1.2 数据清洗
- 通过各种java工具类提取纯文本
- 通过分类器对文章进行打分，过滤低质量文本（需要正样本与负样本）
- 通过simHash等方法去除重复内容
## 1.3 RAG chunk

- 通过规则切分片段后，按上下文每3个片段拼成一个块

## 1.4 抽取问答

- 利用大模型对文档内容进行阅读理解，并让大模型真对此文档拆分问答，进行提问，并给出答案
- 基于拆分的问答对文档进行阅读理解，根据阅读理解出的答案与拆分的答案simhash，如果一致则进入问答库

## 1.5 RAG检索
- 在知识创建过程中，提取内容元数据，例如地区，时间，人名等不同属性与标签，Siamese 
- 对用户的问题进行语义理解，并提取意图信息对元数据进行筛选
- 获取向量检索分词检索结果进行去重，重排

## 1.6 RAG生成
- 将检索回来的内容做为Prompt的上下文
- 对上下文进行压缩，降低大模型使用成本；LongLLMLingua，自动压缩机
- 通过预设prompt模板拼接大模型请求，调用大模型获得输出

## 1.7 大模型json输出
- 在prompt中加入json格式示例
- 获取生成结果后，校验json格式，如果异常则重试

# 2 知识库介绍

知识库只一个内容数据管理与应用的系统，功能模块有采编管理，检索与查看，报表，公告，社区等；

## 2.1 知识库采编设计

1. 从前端传入知识内容（导入或者在线采编）

2. 后端根据不同知识类型选择不同的解析与保存策略

3. 将知识标题，标签等存入数据库，并将发布知识的ID存入知识采编队列；文档知识还需要存入转html队列

4. 搜索引擎服务与其他服务分别定义消费组消费知识采编队列

5. 搜索引擎消费服务将采用多线程消费的方式进行文本分块，转向量，分词等

6. 利用消息队列最少消费一次的的特性，保证数据的最终一致性，将知识纯文本数据存入es

## 2.2 知识检索设计

1. 用户请求经过数据权限校验后，从es中召回片段，并根据规则重排与机器学习重排

2. 根据召回的片段信息获取这些片段的全文内容

3. 利用大模型，结合召回的知识与提示词，进行阅读理解，数据清洗与答案生成

4. 华藏20B已经支持32k上下文约两万字；其他大模型，例如kimi已经支持200+k

## 2.3 搜索引擎消费服务设计

1. 通过redis-stream实现消息通知与消费

2. 消费方法内部定义线程池，充分利用多线程性能优势，线程池初始化入参为：核心线程-ncpu，最大线程-ncpu，超时时间-10秒（实际无用），阻塞队列-长度1024，使用默认线程池工厂，拒绝策略-当阻塞队列满切线程数达到最大线程数，主线程参与任务消费

3. 线程任务使用try-catch，避免异常导致线程异常终止，也可以重写Thread的异常处理

### 2.3.1 线程池执行任务

1. 判断核心线程数是否已满，如果未满则会初始化一个线程并将当前任务作为该线程的firstTask

2. 如果核心线程数已满，则判断队列是否已满，如果未满则加入队列，如果已满则判断最大线程数

3. 当线程任务执行异常或者非核心线程超过闲时时间，则会被回收线程

4. 当线程未从阻塞队列中获取线程，则会进入阻塞状态等待，如果活跃线程大于核心线程则会是timed wait，如果小于等于核心线程，则是进入wait，等待消息队列唤醒

5. 当线程被唤醒又没有获取到任务，则会进入销毁逻辑，销毁后会立马判断是否活跃线程小于核心线程，

## 2.4 用户频繁提交，怎么保证正确的消费

1. 对知识内容增加md5校验，如果md5与上次保存时一致，表示内容没有更改，则仅更新编辑人与编辑时间

2. 在消费es队列时，会使用redis为当前知识添加一个分布式锁，保证同一时间只有一个消费；消费时取知识最新的发布内容

3. 在知识加入es队列前，会将知识加入到redis的set中，如果知识已经在set中存在，且没有存在分布式锁，表示当前知识暂未被消费；则不会重复加入队列

# 3 知识库检索方案

1. 基于es实现知识内容的全文检索，针对知识标题，内容，附件进行分词搜索；知识分类，标签，维度，属性等进行筛选

2. 与其他业务通盘考虑，使用hanlp进行分词，并实现自定义词与同义词

3. 使用rescore进行重评分，实现低翻页率

4. 缓存用户的个人最近的5次搜索结果，防止用户重复提交，降低es压力

5. 正在考虑引入LTR（learning-to-rank）重排序，使召回结果更精确

# 4 数据权限方案

1. 我们通过“用户-角色-数据”的方式实现用户权限的配置

2. 当用户登录时初始化用户的数据权限，将知识ID通过hash后存入bitmap，构建布隆过滤器，当用户退出或token失效时清理bitmap

3. 根据bitmap的返回结果判断用户的数据权限，如果bitmap通过在通过数据关联表校验数据权限



# 5 华住

## 5.1 解释下索引生命周期管理

索引生命周期是es支持日志管理的一部分，es为了支持时序性数据（日志）管理，发布了数据流，数据分层，索引生命周期管理。

- 数据流是es7新推出的功能，用来管理时序性数据，数据流根据索引模板生成后备搜索，然后将搜索和索引请求转发给后备索引，这些后备索引将通过索引生命周期管理

- 数据分层是在es6引入的，是根据时序性数据不同阶段分配给不同机器，例如hot阶段需要高性能机器，code阶段要求则低一些

- 索引生命周期管理是对数据流与数据分层的自动管理，定义好索引生命周期后，es将根据配置自动翻转数据流的后备索引，并将索引迁移到对应分层的机器，压缩索引分片，压缩索引段，生成数据快照等

## 5.2 分词器选择，hanlp相对ik分词器有什么优势

- hanlp中的维特比分词器是隐马尔可夫模型的应用，通过动态规划计算进行分词，相较于ik分词器，维特比分词对于未登录词的召回率更高

- 对于多租户模式，自定义业务词，停词等功能时间比ik简单直接

- 其他功能需要使用分词器，为了保持分词一致性，采用集成hanlp的方案

## 5.3 多级缓存的构造，怎么保证一致性

对于一般的使用，我们在数据变更后，会把id放入消息队列进行消费，达到最终一致。

对于需要强一致性的内容，我们选择先保存到数据库，然后将缓存清理

## 5.4 redis用过哪些数据结构，底层什么样的

用过String，zset，set，bitmap等

redis的String与java的String有什么区别？

jvm结构

StringBuilder对象的生命周期

mysql的优化关注点是哪些

mysql两千万的推荐上限怎么来得

影响b+ tree的层高因素

mysql的page容量

介绍

我拥有6年开发经验，在现公司工作5年，主要负责知识库项目的搜索引擎与内容采编，有丰富的es使用经验并理解其中原理。在22年被提为开发主管，直接下属5人，带领团队完成多个项目交付

## 5.5 管理经验

1. 技术能力突出，能为组员解决难题

2. 技术面广，能够进行技术选型与技术方案判断

3. 产品质量控制，参与置顶开发规范，部署cidi完成代码扫描

4. 保持良好的组内氛围，鼓励讨论甚至争论，理不辨不明

5. 留意组内人员状态，多给予他们正反馈

## 5.6 怎么调研与评估技术方案

1. 确定需求边界，了解功能，性能，安全等

2. 根据需求调研技术栈，结合项目现有技术栈，考虑调研目标的各项优缺点，社区活跃度需要纳入考虑

3. 结合项目现有技术栈，输出设计方案

4. 邀请相关技术人员参与评审，邀请产品经理出席；评审可行性与成本效益

## 5.7 code review有哪些方面

1. 使用工具检查基础的漏洞，alibaba插件与sonarqube

2. 根据迪米特原则，单一职责原则等原则检查代码相关

3. 重要，核心功能的实现方案

4. 处理代码的坏味道，重复代码，超长，if/else等

## 5.8 什么原因触发代码重构/重写

1. 经过长时间需求迭代，代码复杂性指数性提高（代码耦合，散弹式修改，逻辑分支过多）

2. 旧代码扩展功能代价高

3. 人员迭代导致代码维护代价提高

4. 旧项目代码已远远落后重要开源框架（spring等）

# 6 自我介绍

毕业于福建师范大学，截止目前有6年工作经验，在现公司工作5年，期间主要参与智能知识库的研发，从初级开发成长到项目虚线负责人，再到22年被任命为小组研发主管，带领开发小组完成智能知识库重写；知识库是一个针对企业内部数据管理应用的平台，核心模块有数据采编、内容应用、数据权限等，拓展模块有报表，公告，社区等；主要应用技术有Java，ES，MySQL，redis，大模型等

## 6.1 JMM与JVM

JMM是java内存模型，是java描述程序中多线程并发访问共享内存时的规范；JVM是Java虚拟机内存结构；

在方法访问普通共享变量时，会从主内存拷贝一份副本进本地内存中，然后访问本地内存中的内容，当访问volatile修饰的变量时，会直接访问主内存；volatile同时还会禁止指令重排

jvm结构包含程序计数器，虚拟机方法栈，本地方法栈，堆，元空间；

程序计数器保存线程的下一执行指令，虚拟机方法栈保存线程的局部变量表等信息，本地方法栈与虚拟机栈差不多，前三个都是线程私有的；堆和元空间存储的数据则是共享的，堆保存服务的对象实例，元空间保存服务的元数据信息，例如类的信息

在JVM中，堆被划分为新生代和老年代；新生代又进一步划分为eden和s1 s2；Java中常提起的垃圾回收就在堆中，常见的垃圾回收算法有标记-清除，标记-整理，复制，分代收集；垃圾回收器有ParNew，CMS，G1，ZGC等；回收策略有可达性分析与引用计数

### 6.1.1 G1与CMS的对比

1. G1可以管理新生代与老年代整个堆空间，CMS仅管理老年代空间，新生代需要使用其他垃圾回收器（parNew）

2. G1引入了分区的概念，通过逻辑标识每个分区属于老年代，Eden，S1等；垃圾回收也基于分区，因此G1回收后的内存空前是连续的；CMS是基于标记-清除算法，会产生内存碎片

3. G1的STW时间是可以预测的，G1在对堆内对象标记结束后会维护一个分区集合，并根据回收成本排序，进行筛选回收

4. G1在每一次垃圾回收后，会根据本地回收情况自动调整堆内分代比例

# 7 对大模型的认识

清华glm，阿里qianwen，xinghuo

大语言模型是基于超大量数据进行预训练的超大型深度学习模型，多数大模型基于Transformer（一种自注意机制的神经网络架构）进行训练；目前我了解到的应用方向又RAG与Agent，已经对RAG落地，对Agent正在计划中

RAG：为了解决大模型幻觉，数据安全性，知识局限性等问题。RAG落地分为两个环节，一是数据处理：提取-分割-向量化/分词-数据入库；二是应用：用户提问-召回-注入prompt-LLM生成答案

Agent：由规划（planning），记忆（Memory），工具（tools）组成

一个大语言模型智能体框架包含以下核心部分：

- 用户请求 - 表达用户的问题或请求
- 智能体/大脑 - 作为协调者的智能体核心
- 规划- 助于智能体为未来行动做规划
- 记忆 - 管理智能体的历史行为和经验
