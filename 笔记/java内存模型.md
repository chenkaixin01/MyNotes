# 类加载机制

*(也成为动态绑定或晚期绑定)*。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

![](https://pdai.tech/images/jvm/java_jvm_classload_2.png)

### **双亲委派机制过程？**

1. 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；
4. 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

# jvm内存结构

- **线程私有**：程序计数器、虚拟机栈、本地方法区
- **线程共享**：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）

![jvm-framework](https://pdai.tech/images/jvm/jvm/0082zybply1gc6fz21n8kj30u00wpn5v.jpg)

## 程序计数器

又称pc寄存器，用来存放下一条要执行的指令，线程私有；因为cpu一直在切换执行，需要知道下一条指令执行什么，所以需要改变寄存器的值来明确下一条指令；又因为在多线程环境下，cpu不停切换，为了能正确记录下一条指令，将程序计数器设为私有，互不影响

## 虚拟机栈（java方法栈）

每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。

### 栈帧内部结构

- 局部变量表   ：定义在方法内的变量，可以是基础类型变量或者对象引用

- 操作数栈（**表达式栈**）：在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）主要用于保存计算过程的中间结果**，**同时作为计算机过程中变量临时的存储空间，线程私有

- 方法返回地址：用来存放调用该方法的 PC 寄存器的值，当方法返回时，不论是否正常，都会返回该方法调用的位置。正常返回时会执行pc寄存器内的指令；

- 动态连接：确定被调用方法的版本（即调用哪一个方法）

### 本地方法栈

管理本地方法的栈，线程私有

### 堆内存

#### 内存划分

    对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。

将内存逻辑分为三块

- 新生代（年轻代）：新对象和没达到一定年龄的对象都在新生代
- 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
- 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存

![JDK7](https://pdai.tech/images/jvm/jvm/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg)

#### 设置堆内存

根据-xms与-xmx设置堆内存

默认情况下，默认情况下新生代和老年代的比例是 1:2；新生代中eden与s1,s2比例是8: 1 :1;

在java8之后，会默认开启；-XX:+UseAdaptiveSizePolicy，每次gc后都会动态调整堆内存比例

#### 方法区（元空间）

运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。

| JDK版本     | 是否有永久代，字符串常量池放在哪里？                              | 方法区逻辑上规范，由哪些实际的部分实现的？                                               |
| --------- | ----------------------------------------------- | ------------------------------------------------------------------- |
| jdk1.6及之前 | 有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上               | 这个时期方法区在HotSpot中是由永久代来实现的，以至于**这个时期说方法区就是指永久代**                     |
| jdk1.7    | 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；           | 这个时期方法区在HotSpot中由**永久代**（类型信息、字段、方法、常量）和**堆**（字符串常量池、静态变量）共同实现      |
| jdk1.8及之后 | 取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中 | 这个时期方法区在HotSpot中由本地内存的**元空间**（类型信息、字段、方法、常量）和**堆**（字符串常量池、静态变量）共同实现 |

## JMM

![](https://pdai.tech/images/jvm/java-jmm-1.png)

# 垃圾回收器

## 判断对象可回收的方法

- 引用计数器：对象上记录被引用的数量；因为存在循环引用，已放弃

- 可达性分析：从GC Root出发进行搜索，不可达的对象都允许被回收

GC roots：

- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

## 垃圾回收算法：

- 标记清除：可能造成内存碎片

- 标记整理：让存活的对象都往一端移动

- 复制：将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

- 分代：新生代使用复制算法，老年代使用标记整理方法

## G1回收器

- G1 可以直接对新生代和老年代一起回收。

- G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

### 收集动作

1. 初始标记：STW

2. 并发标记：

3. 最终标记

4. 筛选回收：STW，首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划

### G1特点

- 空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

## 内存分片策略

- 对象优先在eden分配

- 大对象直接进老年代

- 长期存活对象进入老年代

- 对象年龄判断

- 空间分配担保

## 触发full gc条件

- 主动调用触发

- 空间分配担保失败

- 老年代空间不足
