# 1 分布式事务

## 1.1 刚性事务（ACID）

刚性事务（如单一数据库事务）完全遵循 ACID 规范，即数据库事务的四大基本特性：

- Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。

- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。

- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。

- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 1.2 柔性事务

柔性事务基于分布式 CAP 理论以及延伸出来的 BASE 理论，相较于数据库事务这一类完全遵循 ACID 的刚性事务来说，柔性事务保证的是 “基本可用，最终一致”，CAP 原理相信大家都很熟悉了，这里我们讲一下 BASE 原则：

- 基本可用（Basically Available）：系统能够基本运行、一直提供服务。

- 软状态（Soft-state）：系统不要求一直保持强一致状态。

- 最终一致性（Eventual consistency）：系统需要在某一时刻后达到一致性要求。

## 1.3 原子提交协议

原子性约束要求在分布式事务结束之时，它的所有操作要么全部执行，要么全部不执行。以分布式事务的原子性来分析，客户端请求访问/更新多个服务器节点上的资源对象，在客户端提交或放弃该事务从而结束事务之后，多个服务器节点的最终状态要么是该事务里的所有步骤都执行成功之后的状态，要么恢复到事务开始前的状态，不存在中间状态。满足这种约束的分布式事务协议则称之为原子提交协议。

### 1.3.1 单阶段原子提交协议

   单阶段原子提交协议（one-phase atomic commit protocol, 1APC）是最简单的一种原子提交协议，它通过设置一个协调者并让它不断地向所有参与者发送提交（commit）或放弃（abort）事务的请求，直到所有参与者确认已执行完相应的操作。

### 1.3.2 两阶段提交

两阶段提交协议包括两个阶段：

- 准备阶段（Prepare Phase） ：协调者向所有参与者发送准备（Prepare）消息。参与者收到消息后，执行事务操作并将结果保存在临时存储中。然后，参与者回复协调者一个表示事务操作是否成功的“同意”（YES）或“放弃”（NO）消息。

- 提交阶段（Commit Phase） ：协调者根据参与者的回复来决定事务是否可以提交。如果所有参与者都回复了“同意”消息，协调者向参与者发送提交（Commit）消息。参与者收到消息后，将事务操作的结果持久化，并释放锁定的资源。如果有任何参与者回复了“放弃”消息，协调者向参与者发送回滚（Rollback）消息。参与者收到消息后，回滚事务操作并释放锁定的资源。

- 

#### 1.3.2.1 缺陷

- 同步阻塞：两阶段提交协议是一个阻塞的协议，在第二阶段期间，参与者在事务未提交之前会一直锁定其占有的本地资源对象，直到接收到来自协调者的 doCommit 或 doAbort 消息。

- 单点故障：两阶段提交协议中只有一个协调者，而由于在第二阶段中参与者在收到协调者的进一步指示之前会一直锁住本地资源对象，如果唯一的协调者此时出现故障而崩溃掉之后，那么所有参与者都将无限期地阻塞下去，也就是一直锁住本地资源对象而导致其他进程无法使用。

- 数据不一致：如果在两阶段提交协议的第二阶段中，协调者向所有参与者发送 doCommit 消息之后，发生了局部网络抖动或者异常，抑或是协调者在只发送了部分消息之后就崩溃了，那么就只会有部分参与者接收到了 doCommit 消息并提交了本地事务；其他未收到 doCommit 消息的参与者则不会提交本地事务，因而导致了数据不一致问题。

### 1.3.3 三阶段提交

三阶段提交协议包括三个阶段：

- 准备阶段（Prepare Phase） ：与两阶段提交协议的准备阶段相同，协调者向所有参与者发送准备（Prepare）消息，参与者收到消息后执行事务操作并将结果保存在临时存储中。然后，参与者回复协调者一个表示事务操作是否成功的“同意”（YES）或“放弃”（NO）消息。

- 预提交阶段（Pre-Commit Phase） ：协调者根据参与者的回复来决定事务是否可以提交。如果所有参与者都回复了“同意”消息，协调者向参与者发送预提交（Pre-Commit）消息。参与者收到消息后，会确认准备好提交事务。然后，参与者回复协调者一个表示预提交状态的“确认”（ACK）消息。

- 提交阶段（Commit Phase） ：协调者收到所有参与者的“确认”消息后，向参与者发送提交（Commit）消息。参与者收到消息后，将事务操作的结果持久化，并释放锁定的资源。如果协调者收到任何参与者的“放弃”消息或在预提交阶段超时，协调者向参与者发送回滚（Rollback）消息。参与者收到消息后，回滚事务操作并释放锁定的资源。

#### 1.3.3.1 三阶段解决了二阶段的问题

阶段提交协议主要着重于解决两阶段提交协议中因为协调者单点故障而引发的同步阻塞问题，在最后的 DoCommit 阶段，如果参与者一直没有收到协调者的 DoCommit 或者 Abort 请求消息时，会在等待超时之后，直接提交事务。

## 1.4 RAFT

### 1.4.1 概述

**Raft是一个用于管理日志一致性的协议**。它将分布式一致性分解为多个子问题：**Leader选举（Leader election）、日志复制（Log replication）、安全性（Safety）、日志压缩（Log compaction）等**。同时，Raft算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现。**Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选者**（Candidate）：

- Leader：**接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志**。

- Follower：**接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志**。

- Candidate：**Leader选举过程中的临时角色**。

![RAFT算法详解](https://ask.qcloudimg.com/http-save/yehe-3700967/719d0b71d6b9523cfd756a2dd648fb2e.jpg)

Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。Raft算法将时间分为一个个的**任期（term）**，每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。

RPC

- **RequestVote RPC**：**候选人在选举期间发起**。

- **AppendEntries RPC**：**领导人发起的一种心跳机制，复制日志也在该命令中完成**。

- **InstallSnapshot RPC**: 领导者使用该RPC来**发送快照给太落后的追随者**。

### 1.4.2 learder选举

Raft 使用一种心跳机制来触发领导人选举，leader定时向flower发送心跳包，当flower在一段时间内没有收到心跳包，会认为没有leader，就会发起选举；而各个节点的超时时间是随机的。当服务刚启动时，所有节点都是flower。

发起选举时，flower将自己转换为Candidate，然后向各个flower发送投票请求。Candidate保持当前状态知道(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导人，(c) 一段时间之后没有任何一个获胜的人

当Candidate获得大多数了针对同一个任期号的选票，那么他就赢得了这次选举并成为leader。每一个服务器最多会对一个任期号投出一张选票。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止发起新的选举。

在等待投票过程中，收到其他节点发来的心跳，判断是否比自身term高，如果高则承认领导人合法，自身转为flower；如果更低则拒绝这次RPC，并继续保持Candidate

当一段时间内选举超时，则开启下一任期，重新选举

### 1.4.3 ES的分布式一致算法与RAFT的区别

1. 节点初始化为候选者，而raft是跟随者
2. ES允许每个节点在每个任期中投出多票
3. 候选人也可以对外投票

es的这部分改动可以让选举更快，但也会是选举更激烈，特别是节点多的情况

### 1.4.4 其他RAFT实现

ETCD

kafka

redis哨兵模式
