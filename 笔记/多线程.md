# 使用场景

## 解析文档内容，转向量与分词

将文档片段转换为向量以及对内容进行分词是一个cpu密集型服务，为了充分利用服务器多核性能，我们为这个服务添加了线程池，

1. 这是一个cpu密集型服务，所以我们的核心cpu数设置为n，阻塞队列上限设置为1024，设置拒绝策略为ThreadPoolExecutor.CallerRunsPolicy

2. 我们使用redis-stream作为消息队列，使用spring封装的监听器，这个监听器内部使用单线程忙轮询实现。

3. 当线程池队列达到上限时，将执行拒绝策略，由主线程执行任务

## 系统异步工具

基于线程池，我们封装了通用的系统异步处理任务工具来。业务系统大部分是IO密集型，所以我们将核心cpu数设置为2n，阻塞队列设置为2048。Spring有异步注解，它的默认实现方式会为每个任务启动一个线程，可能会有oom风险，但我们自定义的工具更符合我们的业务场景

# 线程

线程是操作系统中能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位

## 线程状态

new（新建），runable（可运行），blocking（阻塞），waiting（等待），timed waiting（限期等待），treminate（死亡）

![线程状态](https://pdai.tech/images/pics/ace830df-9919-48ca-91b5-60b193f593d2.png)

# 线程池

线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。

线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。    

## 好处

- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。

## 解决的问题

1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。
2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。
3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。

## 总体设计

线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

### 线程池状态

ThreadPoolExecutor的运行状态有5种，分别为：

![](https://p0.meituan.net/travelcube/62853fa44bfa47d63143babe3b5a4c6e82532.png)

其生命周期转换如下入所示：

![图3 线程池生命周期](https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png)

图3 线程池生命周期

### 任务执行机制

1. 当线程数小于核心数，每进一个任务都会有线程工厂new一个线程

2. 当线程数大于等于核心数，阻塞队列未满，任务进阻塞队列消费，不论是否有线程空闲

3. 当阻塞队列满，线程数小于最大数时，每进入一个任务由线程工厂new一个线程

4. 线程数大于等于最大数，执行拒绝策略

其执行流程如下图所示：

![图4 任务调度流程](https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png)

### 任务申请

由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。

线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：

![图6 获取任务流程图](https://p0.meituan.net/travelcube/49d8041f8480aba5ef59079fcc7143b996706.png)

图6 获取任务流程图

getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。

### 任务拒绝

任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。

## worker线程管理

### worker线程

线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：

```Java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    final Thread thread;//Worker持有的线程
    Runnable firstTask;//初始化的任务，可以为null
}
```

Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。

Worker执行任务的模型如下图所示：

![图7 Worker执行任务](https://p0.meituan.net/travelcube/03268b9dc49bd30bb63064421bb036bf90315.png)

图7 Worker执行任务

线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。

​Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。

1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。

在线程回收过程中就使用到了这种特性，回收过程如下图所示：

![图8 线程池回收过程](https://p1.meituan.net/travelcube/9d8dc9cebe59122127460f81a98894bb34085.png)

### Worker线程增加

其执行流程如下图所示：

![图9 申请线程执行流程图](https://p0.meituan.net/travelcube/49527b1bb385f0f43529e57b614f59ae145454.png)

图9 申请线程执行流程图

### 线程空闲

线程空闲时，核心线程会阻塞，非核心线程在超过一段时间后仍然没有任务就会被回收。线程池通过轮询管理线程

### 线程执行任务

在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：

1. while循环不断通过getTask()方法获取任务

2. getTask()方法从阻塞队列中获取任务

3. 如果阻塞队列中没有数据，且线程数大于核心线程，则调用poll方法，限时阻塞进入timed await状态，在execute方法进入时会被唤醒

4. 如果阻塞队列中没有数据，且线程数不大于核心线程，则调用take方法，直接阻塞进入await状态,在execute方法进入时会被唤醒

5. 当线程退出timed await状态被唤醒，又没有获取到任务，则会结束循环，执行processWorkerExit()

6. processWorkerExit()会判断线程是否正常退出，如果异常退出则任务数减一，然后执行线程销毁

7. 判断线程数是否小于核心线程数，如果小于则创建一个新线程加入线程池

8. 线程任务如果执行异常，则会立即进入processWorkerExit()进行销毁

执行流程如下图所示：

![图11 执行任务流程](https://p0.meituan.net/travelcube/879edb4f06043d76cea27a3ff358cb1d45243.png)

## 其他

### 线程池中线程执行出现异常且未捕获 ，会执行什么样的流程

1. submit与execute方法不同，submit会捕获异常方法返回对象中，线程池无感知；execute会被抛出，线程池能感知到，所以该线程会被销毁

2. 线程池可以通过重写ThreadFactory，往Thread中setUncaughtExceptionHandler；当线程由于未捕获的异常而即将终止时，Java 虚拟机将使用`getUncaughtExceptionHandler`查询线程的`UncaughtExceptionHandler`并将调用处理程序的`uncaughtException`方法，将线程和异常作为参数传递

# CountDownLatch
