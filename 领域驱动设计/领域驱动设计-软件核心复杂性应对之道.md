# 序

###### 软件开发复杂化的原因

最根本的原因在于领域本身错综复杂

###### 本书的目的

描述并简历领域建模艺术的词汇库

###### 领域的最大价值

领域最大的价值在于提供一种通用语言，这种语言时间领域专家（业务人员）和技术人员联系在一起的纽带



# 前言

### 复杂性挑战

###### 应用程序的复杂性

本书认为应用程序的主要复杂性并不在技术上，而是来自于领域本身、用户的活动或者业务



# 第一部分 运用领域模型

### 什么是领域模型

领域模型是对于现实业务的有选择的抽象概括的建模；建模是出于某种目的而概括地反应现实

### 模型在领域驱动设计中的作用

1. 模型和设计的核心相互影响。模型与实现之间的紧密结合在维护和后续开发中，可以基于对模型的理解来解释代码
2. 模型是团队所有成员适应的通用语言的中枢。
3. 模型是浓缩的知识。

### 软件的核心

软件的在于为用户解决领域相关的问题的能力

## 第一章 消化知识

领域模型建模过程中需要有充分的沟通，这有以下两点好处

- 充分沟通能够达成交流的共同语言
- 在交流的过程中与业务人员对于软件模型达成一致

### 1.1 有效建模的要素

1. 模型和实现的绑定。
2. 建立一种基于模型的语言
3. 开发一个蕴含丰富的模型
4. 提炼模型

这些要求我们在项目进行中需要根据对知识了解的进程动态调整模型，使模型更健壮，有点像AI训练

### 1.2 知识消化

知识消化一般是在开发人员的领导下，有开发人员与领域专家组成的团队共同协作，他们共同收集信息，并通过消化而将它组织为有用的形式

信息的来源：

- 领域专家脑中的知识
- 遗留系统或同领域的其他项目中积累的经验

在这一步 中，要求程序员要兼任系统分析的工作，建开发工作前探

### 1.3 持续学习

当开始编写软件时，其实我们所知甚少

这一步要求项目团队包括个人要能够快速学习知识，消化知识

对于开发人员，快速学习业务知识能够更快抽象出更好的模型，针对当前领域具有更好的扩展性

### 1.4 知识丰富的设计

业务名词，业务活动和规则涉及的实体都是领域的核心

知识消化所产生的模型能够反映出对知识的深层理解。在模型发生改变的同时，开发人员对实现的重构，以反应出模型的变化，这样新知识就被合并到应用程序中

### 1.5 深层模型

随着对领域知识的了解深入或者知识改变，领域模型需要有相应的改变能够更契合领域知识

知识消化是一种探索，它永无止境

## 第二章 交流与语言的使用

领域模型：领域模型是一组得自于项目人员头脑中的概念，以及反应了领域深层的术语和关系；这些术语和相互关系提供了模型语言的予以

### 2.1 模式：Ubiquitous Language（通用语言）

###### 为什么要用通用语言？

如果语言支离破碎，那么在项目沟通的过程中就避免不了翻译，而所有的翻译都避免不了误解的风险

###### Ubiquitous Language的词汇

- 类和主要操作的名称
- 语言中的术语
- 讨论模型中已经明确的规则

###### 通用语言应用的注意点：

- 将模型作为语言的支柱。确保团队在内部的所有交流总以及代码中坚持使用这种语言。在画图、写东西、特别是讲话时也要使用这种语言

- 通过不同的表示方法来消除难点。然后重构代码，重新命名类、方法和模块，以便与新模型保持一致。解决交谈中的术语混淆问题，
- 要认识到，通用语言的更改就是对模型的更改
- 领域专家应该地址不合适或无法充分表达领域理解的术语或结构，开发人员应密切关注那些将会妨碍设计的有歧义和不一致的地方

### 2.2  ”大声地“建模

改善模型的最佳方式之一就是通过对话来研究，试着大声说出可能的模型变化中的各种结构

讨论系统时要结合模型。使用模型元素及其交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要讲的话，然后将这些新想法应用到图和代码中

### 2.3  一个团队，一种语言

如果连经验丰富的领域专家都不能理解模型，那么模型一定出了什么问题。模型的构建与反馈都应该面向领域专家

### 2.4 文档和图

图是一种沟通和解释手段，它们可以促进头脑风暴。简洁的小图能够很好地实现这些目标，它们只体现思想纲要，设计的重要细节应该在代码中体现出来

#### 2.4.1 书面设计文档

###### 评估文档的总体原则

- 文档应作为代码和口头交流的补充
- 文档应该鲜活且保持最新

通过将文档减至最少，并且主要用它来补充代码和口头交流，就可以避免文档与项目脱节

#### 2.4.2 完全依赖可执行代码的情况



### 2.5 解释性模型

解释性模型可以包含那些提供上下文的领域方面



## 第三章 绑定模型和实现

### 3.1 模式：Model-Driven Design

Model-Driven Design(模型驱动设计)寻求一种能够同时满足分析模型和程序设计需求的单一模型

如果模型对于程序的实现来说显得不太实用时，我们必须重新设计它。而如果模型无法忠实的描述领域的关键概念，也必须重新设计它

###### 模型应该满足以下要求

- 方便软件可以更加自然地实现模型
- 能够支持健壮的通用语言

从模型中获取用于程序设计和基本职责分配的术语。让程序代码成为模型的表达，代码的改变可能会是模型的改变。而其影响势必要波及接下来响应的项目活动

完全依赖模型的实现通常需要支持建模范式的软件开发工具和语言，比如面向对象编程

### 3.2 建模范式额工具支持

只有代码表达模型概念时，对象设计的真正突破之处才彰显出来

### 3.3 揭示主旨：为什么模型对用户至关重要

### 3.4 模式：Hands-On Modeler

任何参与建模的技术人员，不管在项目中的主要职责是什么，都必须花时间了解代码。任何负责修改代码的人员则必须学会用代码来表达模型。每一个开发人员都必须不同程度地参与模型讨论并且与领域专家保持联系。参与不同工作的人都必须有意识得通过通用语言与接触代码的人及时交换关于模型的想法

## 第四章 分离领域

### 4.1 模式：Layered Architecture(分层架构)

###### 分层的价值

分层的价值在于每一层都只代表程序中的某一特定方面。这种限制使每个方面的设计都更具内聚性，更容易解释。

###### 通用分层

| 分层                   | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 用户界面层（或表示层） | 负责向用户显示信息和解释用户指令。这里的用户可以是另一个计算机系统，不一定是使用用户界面的人 |
| 应用层                 | 定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，与其他系统的应用层进行的交互的必要渠道<br />应用层要尽量简单，不包含业务规则或知识，而只为下一层中的领域对象协调任务，分配工作，是他们互相协作。它没有反应业务情况的状态，但却可以具有另一种状态，为用户或程序显示某个任务的进度 |
| 领域层（或模型层）     | 负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的，但反映业务情况的状态是由本层控制并且使用的。领域层是业务软件的核心 |
| 基础设施层             | 位上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件等。<br />基础设施差还能通过架构框架来支持4个层次间的交互模式 |



领域对象应该将重点放在如何表达领域模型上，而不需要考虑自己的显示和存储问题，也无需管理应用任务等内容。这使得模型的含义足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效地使用这些知识

#### 4.1.1 将各层关联起来

层与层之间的依赖关系只能是单向的，上层可以直接使用或操作下层元素，方法是通过调用下层元素的公共接口，保持对下层元素的引用（至少是暂时的），以及采用常规的交互手段。如果下层元素需要与上层元素进行通信,则需要采用另一种通信机制，使用架构模式来连接上下层，如回调模式或Observers模式

#### 4.1.2 架构框架

###### 使用架构的目的

项目团队应该明确使用架构的目的：建立一种可以表达领域模型的实现，并且用它来解决重要问题。项目团队必须要想方设法让框架满足这些需求，即使这意味着抛弃框架中的一些功能

### 4.2 领域层是模型的精髓

领域模型是一系列概念的集合。“领域层”则是领域模型以及所有预期相关的设计元素的表现，它有业务逻辑的设计和实现组成

### 4.3 模式：The Smart UI “反模式”

###### smart ui 的优点

- 效率高，能在段时间内实现简单的应用程序
- 能力较差的开发人员可以几乎不经过培训就采用它
- 设置可以克服需求分析上的不足，只要把原型发布给用户，然后根据用户反馈快速修改软件产品即可
- 程序之间彼此独立，这样可以相对准确地爱拍小模块的交付日期。额外扩展简单的功能也很容易
- 可以很顺利地使用关系数据库，能够提供数据级的整合。
- 可以使用第四代语言工具（第四代语言是面向数据库的语言，以数据管理系统所提供的功能为核心）
- 移交应用程序后，维护程序员可以迅速冲洗他们不明白的代码段，因为修改代码只会影响到代码所在的用户界面

###### smart ui的缺点

- 不通过数据库很难集成应用模块
- 没有对行为的重用，也没有对业务问题的抽象。每当操作用到业务规则时，都必须重复这些规则
- 快速的原型建立和迭代很快会达到其极限，因为抽象的缺乏限制了重构的选择
- 复杂的功能很快会让你无所适从，所以程序的扩展只能是简单的应用模块，没有很好的方法来实现更丰富的功能

### 4.4 其他分离方式

## 第五章 软件中所表示的模型

每个设计决策都应该实在深入理解领域中的某些深层知识之后做出的。高内聚低耦合这种思想可应用于概念本身

### 5.1 关联

###### 控制关联的方法

1. 规定一个遍历的方向
2. 添加一个限定符，以便有效地减少多重关联
3. 消除不必要的关联

### 5.2 模式：Entity（又称为Reference Object）

在对象的多个实现、存储形式和真实世界的参与者之间，概念性标识必须是匹配的，属性可以不匹配

主要由标识定义的对象呗称作Entity。Entity由特殊的建模和设计思路。它们具有生命周期，这期间它们的形式和内容可能发生根本变化，但必须保持一种内在的连续性

Entity应该是一个名词，例如一次银行交易的记录

#### 5.2.1 Entity建模

Entity最基本的职责是确保连续性，以便使其行为更清楚且可预测。保持实体的简练是实现这一责任的关键。不要将注意力集中在属性或行为上

#### 5.2.2 设计标识操作

不管系统是如何定义，都必须确保标识属性在系统中是唯一的，即使是在分布式系统中，或者对象已被归档，也必须确保标识的唯一性

关联表对应的Entity可以通过关联的外键构成唯一，可以不需要再生成唯一的符号作为唯一标识

### 5.3 模式：Value Object

用于描述领域某个方面而本身没有概念标识的对象称为Value Object（值对象）

#### 5.3.1 设计Value Object

### 5.4 模式：Service

###### 好的service的特征

- 与领域概念相关的操作不是Entity或Value Object的一个自然组成部分
- 接口是根据领域模型的其他元素定义的
- 操作是无状态的

#### 5.4.1 Service与孤立的领域层

应用层负责通知的设置，而领域层负责确定是否满足临界值，尽管这项任务可能并不需要使用Service（应用层不应有参数的校验）

领域或应用层的Service的行为类似于将领域的一些潜在功能组织起来以执行某种任务的脚本

#### 5.4.2 粒度

#### 5.4.3 对Service的访问

### 5.5 模式：Module（也称为Package）

Module之间应该是低耦合的，而在Module的内部则是高内聚的

Module并不仅仅是代码的划分，而且也是概念的划分

Module是一种表达机制，Module的选择应该取决于被划分到模块中的对象的意义

如果说模型讲述了一个故事，那么Module就是这个故事的各个章节

#### 5.5.1 敏捷的Module

#### 5.5.2 通过基础设施打包时的隐患

除非真正有必要将代码分布到不同的服务器上，否则就把实现单一概念对象的所有代码放在同一个模块中（如果不能放在同一个对象的话）

利用打包把领域层从其他代码中分离出来。否则，就尽可能让领域开发人员自由地决定领域对象的打包方式，以便支持他们的模型和设计选择

## 5.6 建模范式

### 5.6.1 对象范式流行的原因

### 5.6.2 对象世界中的非对象

### 5.6.3 在混合范式中坚持使用Model-Driven Design









